ex00

Для каждого упражнения ваша основная должна проверять все.
Конструкторы и деструкторы каждого класса должны иметь специфический вывод.
Создайте простой и полный базовый класс Animal.
Класс животных получил один защищенный атрибут:
• тип std :: string;
Создайте класс Dog, унаследованный от Animal.
Создайте класс Cat, унаследованный от Animal.
(для класса животных тип можно оставить пустым или присвоить любое значение).
Каждый класс должен указать свое имя в поле Тип, например:
Тип класса Dog должен быть инициализирован как «Dog».
Каждое животное должно уметь использовать метод makeSound ().
Этот метод отобразит соответствующее сообщение на стандартных выходных данных в зависимости от класса.
------->>>>>>>SCREEN
Это должно вывести конкретный makeSound класса Dog и cat, а не животного.
Чтобы быть уверенным, вы создадите класс WrongCat, наследующий класс WrongAnimal,
который будет выводить функцию makeSound () WrongAnimal при тестировании в тех же условиях.


ex01

Вы будете повторно использовать классы Ex00.
Создайте один класс под названием Brain.
Мозг будет содержать массив из 100 std :: string, называемый идеями.
Теперь у собак и кошек будет личный атрибут мозга *.

После создания Собака и Кошка инициализируют свой Мозг * новым Мозгом (); При уничтожении Собака и Кошка удаляют свой Мозг.
Ваша основная часть будет создавать и заполнять массив животных, половина из которых будет собакой, а другая половина - кошкой.
Перед выходом ваш main будет перебирать этот массив и удалять все Animal. Вы должны удалить кошку и собаку как животное.
Копия Кошки или Собаки должна быть «глубокой». Ваш тест должен показать, что копии глубокие!
Конструкторы и деструкторы каждого класса должны иметь специфический вывод. Должны быть вызваны соответствующие деструкторы.
----->>>>>>>SCREEN


ex02

В конце концов, обычное животное не имеет смысла.
Например, он не издает звука!
Чтобы избежать ошибок в будущем, класс животных по умолчанию не должен быть инстанцируемым.
Исправьте класс Animal, чтобы никто не создал его по ошибке.
Остальное должно работать как раньше.

ex03

В C ++ 98 (даже в C ++ 20) нет интерфейса, но принято называть чистый абстрактный класс интерфейсом.
Итак, в этом последнем упражнении давайте попробуем интерфейсы и подведем итоги!
Завершите определение следующего класса AMateria и реализуйте необходимые функции-члены.
------>>>>>>>>SCREEN
Создайте конкретную Materias Ice and Cure. Их типом будет их имя в нижнем регистре («лед» для льда и т. Д.).
Их метод clone (), конечно же, вернет новый экземпляр настоящего типа Материи.
Что касается использования метода (ICharacter &), он будет отображать:
• Лед: «* стреляет ледяной молнией в ИМЯ *»
• Cure: «* лечит раны NAME *»
(Конечно, замените NAME именем символа, заданного в качестве параметра.)
Создайте класс Character, который будет реализовывать следующий интерфейс:
------>>>>>>SCREEN
Персонаж обладает инвентарем не более 4 Материей, пустых в начале. Он будет использовать Материю в слотах с 0 по 3 в указанном порядке.
Если мы попытаемся оборудовать Материю в полном инвентаре или использовать / снять несуществующую Материю, ничего не предпринимайте.
Метод unquip НЕ должен удалять Материю!
Метод use (int, ICharacter &) должен будет использовать Materia в слоте idx и передавать target в качестве параметра методу AMateria :: use.
У вашего персонажа должен быть конструктор, принимающий его имя в качестве параметра.
Копирование или присвоение Персонажа, конечно, должно быть глубоким. Старая Материя Персонажа должна быть удалена. То же самое при уничтожении персонажа.
Создайте класс MateriaSource, который должен будет реализовать следующий интерфейс:
-------->>>>>>SCREEN
learnMateria должна скопировать Materia, переданную в качестве параметра, и сохранить ее в памяти для последующего клонирования.
Во многом так же, как и в случае с персонажем, Источник может знать не более 4 Материей, которые не обязательно уникальны.
createMateria (std :: string const &) вернет новую Materia, которая будет копией Materia (ранее изученной источником), тип которой равен параметру.
Возвращает 0, если тип неизвестен.
Короче говоря, ваш Источник должен уметь изучать «шаблоны» Материи и воссоздавать их по запросу.
После этого вы сможете создать Материю, не зная ее «настоящего» типа, просто идентифицируя ее по строке.
------>>>>>>>>SCREEN
