ex00
Здесь надо сделать класс! Как оригинально!
Класс будет называться ClapTrap и будет иметь следующие частные атрибуты, инициализированные указанными значениями:
• Name (Parameter of constructor)
• Hitpoints (10)
• Energy points (10)
• Attack damage (0)
Вы также дадите ему несколько общедоступных функций, чтобы сделать его более реалистичным:
• void attack(std::string const & target)
• void takeDamage(unsigned int amount)
• void beRepaired(unsigned int amount)
Во всех этих функциях вы должны отображать что-то, чтобы описать происходящее. Например, функция атаки может отображать что-то вроде:
ClapTrap <name> attack <target>, causing <damage> points of damage
Конструктор и деструктор также должны что-то отображать, чтобы люди могли видеть, что они были вызваны.
Вы предоставите основную функцию с достаточным количеством тестов, чтобы продемонстрировать, что ваш код работает.

ex01
Поскольку у нас никогда не будет достаточно Claptrap, теперь ты сделаешь еще одну.
Класс будет называться ScavTrap и будет унаследован от ClapTrap, конструктор, деструктор и атака должны использовать разные выходные данные.
В конце концов, Claptrap должен обладать определенной индивидуальностью. У класса ScavTrap будут сообщения о создании и уничтожении.
Кроме того, должна присутствовать правильная цепочка построения / разрушения (когда вы строите ScavTrap, вы должны начать с создания ClapTrap...
Разрушение происходит в обратном порядке), и тесты должны это показать.
ScavTrap будет использовать атрибуты Claptrap (вам нужно соответственно изменить Claptrap)! И должны инициализировать их:
• Name (Parameter of constructor)
• Hitpoints (100)
• Energy points (50)
• attack damage (20)
ScavTrap также будет иметь новую специальную функцию:
void guardGate ();
эта функция будет отображать сообщение на стандартных выходах, чтобы сообщить, что ScavTrap вошел в режим Gate keeper.
Расширьте свою основную функцию, чтобы все проверить.

ex02
Изготовление Claptraps, вероятно, начинает действовать вам на нервы.
Теперь вы создадите класс FragTrap, унаследованный от ClapTrap.
• Имя (параметр конструктора)
• Здоровье (100)
• Очки энергии (100)
• урон от атаки (30)
У класса FragTrap будут сообщения о создании и уничтожении.
Кроме того, должна присутствовать правильная цепочка построения / разрушения (когда вы строите FragTrap, вы должны начать с создания ClapTrap...
Уничтожение происходит в обратном порядке), и тесты должны это показать.
Специальная функция для FragTrap будет void highFivesGuys (void) и будет отображать положительный запрос высокой пятерки в стандартном выводе.
Расширьте свою основную функцию, чтобы все проверить.

ex03
Теперь вы создадите монстра, сделав Claptrap наполовину Fragtrap, наполовину ScavTrap.
Он будет называться DiamondTrap и будет унаследован как от FragTrap, так и от ScavTrap.
Очень рискованно и ужасно, что класс DiamondTrap объявит частный атрибут с именем name, подобный тому, который находится внутри ClapTrap.
Его атрибуты и функции будут выбраны из любого из его родительских классов:
• Name (Parameter of constructor)
• Claptrap::Name (Parameter of constructor + "_clap_name")
• Hitpoints (Fragtrap)
• Energy points (Scavtrap)
• Attack damage (Fragtrap)
• attack (Scavtrap)
У него будут особые функции обоих.
Как обычно, ваш main будет расширен для тестирования нового класса.
Конечно, часть Алмазной ловушки будет создана один раз, и только один раз ... Да, есть хитрость.
DiamondTrap будет иметь новую функцию void whoAmI (); который отобразит его имя и его имя clapTrap.
