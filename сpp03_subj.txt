Упражнение 00: Аааа... ОТКРЫТО!
Здесь вы должны создать класс! Как оригинально! 

Класс будет называться ClapTrap и будет иметь следующие приватные атрибуты, инициализированные в указанные значения:
- Имя (Параметр конструктора)
- Хитпоинты (10)
- Очки энергии (10)
- Урон от атаки (0)
Вы также дадите ему несколько публичных функций, чтобы сделать его более похожим на жизнь:
- void attack(std::string const & target)
- void takeDamage(unsigned int amount)
- void beRepaired(unsigned int amount)

Во всех этих функциях вы должны отображать что-то, чтобы описать происходящее. Например, функция атаки может отображать что-то вроде:
ClapTrap <name> attack <target>, causing <damage> points of damage! 

Конструктор и деструктор также должны что-то отображать, чтобы люди могли видеть, что они были вызваны. 
Вы предоставите главную функцию с достаточным количеством тестов, чтобы продемонстрировать работоспособность вашего кода.



Упражнение 01: Сирена, любовь моя!
Поскольку у нас никогда не может быть достаточно Клаптрапов, сейчас вы создадите еще один. 

Класс будет называться ScavTrap, и будет наследоваться от ClapTrap, конструктор, деструктор и атака должны использовать разные выходы.
В конце концов, клаптрап должен иметь некоторую степень индивидуальности. 

Класс ScavTrap будет иметь свои сообщения о строительстве и разрушении.
Кроме того, правильная должна присутствовать правильная цепочка строительства/разрушения
(Когда вы строите ScavTrap, вы должны начать с постройки ClapTrap... Разрушение происходит в обратном порядке), и тесты должны показать это. 

ScavTrap будет использовать атрибуты Claptrap (Вы должны изменить Claptrap соответствующим образом)! И должен их инициализировать:
- Имя (Параметр конструктора)
- Хитпоинты (100)
- очки энергии (50)
- урон атаки (20)

ScavTrap также будет иметь новую специфическую функцию: void guardGate();
эта функция выводит сообщение на стандартные выходы для оповещения о том, что ScavTrap вошел в режим хранителя врат. 

Расширьте вашу главную функцию, чтобы проверить все.



Упражнение 02: Повторяющаяся работа
Создание ловушек Claptraps, вероятно, начинает действовать вам на нервы.

Сейчас вы создадите класс FragTrap, который наследуется от ClapTrap.
- Имя (Параметр конструктора)
- Точки попадания (100)
- очки энергии (100)
- урон от атаки (30)

Класс FragTrap будет иметь свои сообщения о построении и уничтожении.
Также должна присутствовать правильная цепочка построения/уничтожения
(Когда вы строите FragTrap, вы должны начать с построения ClapTrap... Разрушение происходит в обратном порядке), и тесты должны это показать. 

Конкретная функция для FragTrap будет void highFivesGuys(void) и выведет на стандартный вывод положительный запрос "дай пять".

Расширьте вашу главную функцию, чтобы протестировать все.
 


Упражнение 03: Теперь это странно!
Сейчас вы создадите монстра, создав Claptrap, который будет наполовину Fragtrap, наполовину ScavTrap. 

Он будет называться DiamondTrap и будет наследоваться как от FragTrap, так и от ScavTrap. 

Очень рискованный и ужасный поступок Класс DiamondTrap объявит приватный атрибут name, подобный тому, что есть в ClapTrap. 

Его атрибуты и функции будут выбраны из любого из его родительских классов:
- Name (Параметр конструктора)
- Claptrap::Name (Параметр конструктора + "_clap_name")
- Хитпоинты (Фрагтрап)
- Очки энергии (Scavtrap)
- Урон от атаки (Фрагтрап)
- атака (Scavtrap)
Он будет иметь специальные функции обоих. 

Как обычно, ваша основная часть будет расширена для тестирования нового класса. 

Разумеется, часть Claptrap в Diamondtrap будет создана один раз, и только один раз... Да, есть одна хитрость. 

DiamondTrap будет иметь новую функцию void whoAmI(); которая будет отображать его имя и имя его clapTrap.
